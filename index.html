<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Owami's Library ‚Äî Dtech Collection</title>
<style>
  :root {
    /* DTECH X OWAMI THEME - DEFAULT DARK */
    --accent: #00d4ff;        /* Tech Blue */
    --accent-light: #2979ff;  /* Light Blue */
    --accent-dark: #00a2c7;   /* Darker Blue */
    --highlight: #ff007f;     /* Owami Pink */
    --text: #e0e0e0;
    --text-light: #b0b0b0;
    --muted: #6e6e6e;
    --background: #0a0a0a;    /* Deep Black */
    --card-bg: #141414;       /* Dark Gray */
    --border: #333333;

    --book-font: "Georgia","Times New Roman", serif;
    --ui-font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    --reader-font-size: 9px;
    --page-words: 500;
  }

  /* Force Dark Mode Default */
  body {
    background: var(--background);
    color: var(--text);
    font-family: var(--ui-font);
    line-height: 1.5;
    margin: 0;
    height: 100%;
  }

  /* Specific Override for Light Mode if toggle is kept (but we aim for dark first) */
  body.light-mode {
    --accent: #0077cc;
    --accent-light: #4da6ff;
    --accent-dark: #005fa3;
    --highlight: #d6006c;
    --text: #1a1a1a;
    --text-light: #4a4a4a;
    --muted: #888;
    --background: #f5f5f7;
    --card-bg: #ffffff;
    --border: #e0e0e0;
  }

  /* SCROLLBAR */
  ::-webkit-scrollbar { width: 8px; height: 8px; }
  ::-webkit-scrollbar-track { background: var(--background); }
  ::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--accent); }

  .topbar {
    background: rgba(20, 20, 20, 0.8);
    backdrop-filter: blur(10px);
    padding: 16px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: sticky;
    top: 0;
    z-index: 30;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
  }

  .brand {
    font-weight: 700;
    font-size: 22px;
    color: var(--text);
    display: flex;
    align-items: center;
    gap: 12px;
    letter-spacing: -0.5px;
  }

  .brand-icon {
    font-size: 24px;
    filter: drop-shadow(0 0 5px var(--accent));
  }

  .brand-text em { color: var(--highlight); font-style: normal; }

  .dtech-badge {
    background: var(--accent);
    color: #000;
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: 800;
    letter-spacing: 1px;
    text-transform: uppercase;
    vertical-align: middle;
    box-shadow: 0 0 10px rgba(0, 212, 255, 0.4);
  }

  .tabs {
    display: flex;
    gap: 8px;
    background: #1f1f1f;
    padding: 4px;
    border-radius: 12px;
    border: 1px solid var(--border);
  }

  .tab {
    padding: 8px 20px;
    border-radius: 8px;
    background: transparent;
    color: var(--text-light);
    cursor: pointer;
    font-weight: 500;
    font-size: 14px;
    transition: all 0.3s ease;
  }

  .tab:hover { color: var(--text); }

  .tab.active {
    background: var(--accent-light);
    color: #fff;
    box-shadow: 0 0 15px rgba(41, 121, 255, 0.4);
  }

  .search-row {
    display: flex;
    gap: 12px;
    align-items: center;
    padding: 20px 24px;
    background: var(--card-bg);
    border-bottom: 1px solid var(--border);
  }

  #searchInput {
    padding: 12px 16px;
    border-radius: 10px;
    border: 1px solid var(--border);
    flex: 1;
    max-width: 500px;
    font-size: 15px;
    background: #000;
    color: var(--text);
    transition: all 0.3s ease;
  }

  #searchInput:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.2);
  }

  #genreFilter {
    padding: 12px 16px;
    border-radius: 10px;
    border: 1px solid var(--border);
    background: #000;
    color: var(--text);
    font-size: 15px;
    min-width: 200px;
  }

  .layout {
    max-width: 1400px;
    margin: 24px auto;
    padding: 0 20px;
  }

  .stats {
    color: var(--muted);
    margin: 12px 0 20px;
    font-size: 14px;
    font-family: monospace;
  }

  .loading-progress {
    display: flex;
    align-items: center;
    gap: 10px;
    margin: 10px 0;
    padding: 15px;
    background: rgba(0, 212, 255, 0.05);
    border: 1px solid rgba(0, 212, 255, 0.2);
    border-radius: 8px;
  }

  .progress-bar {
    flex: 1;
    height: 6px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
  }

  .progress-fill {
    height: 100%;
    background: var(--accent);
    border-radius: 4px;
    transition: width 0.3s ease;
    box-shadow: 0 0 10px var(--accent);
  }

  .progress-text {
    font-size: 13px;
    color: var(--accent);
    min-width: 120px;
    text-align: right;
    font-family: monospace;
  }

  /* SECTIONS */
  .section-title {
    color: var(--text);
    border-bottom: 1px solid var(--border);
    padding-bottom: 12px;
    font-size: 24px;
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 25px;
    letter-spacing: -0.5px;
  }

  .section-title:before {
    font-size: 24px;
    filter: grayscale(100%); /* Desaturate icons for cleaner look */
  }

  /* HOME */
  #homeSection {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  .genre-section {
    margin-bottom: 30px;
    background: var(--card-bg);
    padding: 20px;
    border-radius: 16px;
    border: 1px solid var(--border);
  }

  .genre-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid var(--border);
  }

  .genre-title {
    font-size: 18px;
    color: var(--accent);
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .genre-count {
    background: #333;
    color: var(--text-light);
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-family: monospace;
  }

  .books-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
    gap: 20px;
  }

  .book-card {
    background: #000;
    border-radius: 12px;
    padding: 12px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    gap: 10px;
    min-height: 200px;
    transition: all 0.3s ease;
    border: 1px solid #222;
    cursor: pointer;
    position: relative;
    overflow: hidden;
  }

  .book-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(0, 212, 255, 0.15);
    border-color: var(--accent);
  }

  /* Highlight bar */
  .book-card:before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(90deg, var(--accent), var(--highlight));
    opacity: 0.7;
  }

  .cover-wrap {
    height: 140px;
    border-radius: 8px;
    overflow: hidden;
    background: #111;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  .cover-wrap img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.9;
    transition: opacity 0.3s;
  }

  .book-card:hover .cover-wrap img { opacity: 1; }

  .cover-placeholder {
    padding: 10px;
    text-align: center;
    font-weight: 700;
    color: #444;
    font-size: 12px;
    text-transform: uppercase;
  }

  .book-title {
    font-weight: 600;
    font-size: 14px;
    line-height: 1.4;
    color: var(--text);
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  .book-author {
    color: var(--muted);
    font-size: 12px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .book-genre {
    color: var(--accent);
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    opacity: 0.8;
  }

  .card-row {
    display: flex;
    gap: 8px;
    align-items: center;
    margin-top: auto;
  }

  .btn {
    padding: 8px 12px;
    border-radius: 6px;
    border: none;
    background: var(--accent-light);
    color: #fff;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s ease;
    flex: 1;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .btn:hover {
    background: var(--accent);
    box-shadow: 0 0 10px var(--accent);
  }

  .small-btn {
    padding: 8px;
    border-radius: 6px;
    border: 1px solid #333;
    background: #111;
    color: var(--text-light);
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .small-btn:hover {
    background: #222;
    color: var(--highlight);
    border-color: var(--highlight);
  }

  .load-more-btn, .load-more-genres-btn {
    background: #222;
    color: var(--text);
    border: 1px solid var(--border);
    padding: 12px 24px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 500;
    display: block;
    margin: 20px auto;
    transition: all 0.3s ease;
    font-size: 14px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .load-more-btn:hover, .load-more-genres-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(0, 212, 255, 0.05);
  }

  /* CONTINUE / READ LATER */
  #continueSection, #readLaterSection, #favoritesSection {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  .continue-grid, .readlater-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
  }

  .continue-card, .readlater-card {
    background: var(--card-bg);
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    display: flex;
    flex-direction: column;
    gap: 15px;
    transition: all 0.3s ease;
    border: 1px solid var(--border);
    position: relative;
  }

  .continue-card { border-left: 3px solid var(--accent); }
  .readlater-card { border-top: 3px solid var(--highlight); }

  .continue-card:hover, .readlater-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent-light);
    box-shadow: 0 8px 20px rgba(0,0,0,0.4);
  }

  .continue-title, .readlater-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--text);
    margin: 0;
  }

  .continue-date, .readlater-date {
    font-size: 11px;
    color: var(--accent);
    background: rgba(0, 212, 255, 0.1);
    padding: 2px 8px;
    border-radius: 4px;
    text-transform: uppercase;
  }

  .continue-author, .readlater-author {
    color: var(--muted);
    font-size: 13px;
  }

  .progress-info { color: var(--text-light); }
  .progress-bar { background: #333; }

  .continue-btn {
    background: var(--accent-light);
    color: white;
    border: none;
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
  }

  .readlater-open {
    background: var(--highlight);
    color: white;
    border: none;
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
  }
  .readlater-open:hover { background: #d6006c; box-shadow: 0 0 10px var(--highlight); }

  .remove-btn, .readlater-remove {
    background: transparent;
    color: var(--muted);
    border: 1px solid var(--border);
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
  }

  .remove-btn:hover, .readlater-remove:hover {
    color: #ff4444;
    border-color: #ff4444;
  }

  /* READER FULLSCREEN */
  .reader-fullscreen {
    background: #050505;
    color: #ccc;
  }

  /* Reader Theme Overrides */
  .reader-fullscreen.theme-light { --reader-bg: #f0f0f0; --reader-text: #111; --page-bg: #fff; }
  .reader-fullscreen.theme-sepia { --reader-bg: #f4ecd8; --reader-text: #5b4636; --page-bg: #fdfaf6; }
  .reader-fullscreen.theme-dark { --reader-bg: #050505; --reader-text: #b0b0b0; --page-bg: #141414; }

  .reader-header {
    height: 60px;
    background: var(--card-bg);
    border-bottom: 1px solid var(--border);
    padding: 0 20px;
  }

  .reader-title {
    font-family: var(--ui-font);
    font-size: 14px;
    color: var(--text-light);
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  .reader-back-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--accent);
    padding: 6px 12px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
  }

  .reader-back-btn:hover {
    background: rgba(0, 212, 255, 0.1);
    border-color: var(--accent);
  }

  .page {
    border: 1px solid #222;
    box-shadow: 0 0 50px rgba(0,0,0,0.5);
  }

  .reader-footer {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding-bottom: 20px;
    width: 80%;
    max-width: 600px;
  }

  .reader-progress-bar {
    width: 100%;
    height: 4px;
    background: #333;
    border-radius: 2px;
    overflow: hidden;
  }

  .reader-progress-fill {
    height: 100%;
    width: 0%;
    background: var(--highlight); /* Her dash of pink */
    box-shadow: 0 0 10px var(--highlight);
    transition: width 0.3s ease;
  }

  .page-indicator {
    background: rgba(0,0,0,0.8);
    border: 1px solid #333;
    color: var(--accent);
    font-family: monospace;
  }

  .nav-arrow {
    background: rgba(0,0,0,0.8);
    color: var(--accent);
    border: 1px solid #333;
  }

  /* Toast */
  .toast {
    background: var(--card-bg);
    color: var(--accent);
    border: 1px solid var(--accent);
    box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
  }

  /* Bottom Nav for Mobile */
  .bottom-nav {
    display: none;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(10, 10, 10, 0.95);
    backdrop-filter: blur(10px);
    border-top: 1px solid var(--border);
    padding: 10px 0 15px; /* Extra padding for bottom */
    z-index: 40;
    justify-content: space-around;
    box-shadow: 0 -4px 20px rgba(0,0,0,0.4);
  }

  .nav-item {
    text-align: center;
    font-size: 10px;
    color: var(--text-light);
    cursor: pointer;
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    transition: all 0.2s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .nav-item-icon {
    font-size: 20px;
    margin-bottom: 2px;
    filter: grayscale(100%);
    transition: all 0.2s;
  }

  .nav-item.active {
    color: var(--accent);
  }

  .nav-item.active .nav-item-icon {
    filter: grayscale(0%);
    text-shadow: 0 0 10px var(--accent);
  }

  @media (max-width: 768px) {
    .topbar { flex-direction: row; } /* Keep logo left */
    .topbar .tabs { display: none; }
    .bottom-nav { display: flex; }
    .layout { margin-bottom: 90px; } /* Add space for bottom nav */
    .search-row { flex-direction: column; }
    .books-grid { grid-template-columns: 1fr 1fr; }
  }
</style>
</head>
<body>

<!-- Top -->
<div class="topbar">
  <div class="brand">
    <span class="brand-icon">üìö</span>
    <div class="brand-text"><em>Owami's</em> Library <span class="dtech-badge">Dtech</span></div>
  </div>
  <div class="tabs" role="tablist" aria-label="Sections">
    <div class="tab active" id="tab-home">Home</div>
    <div class="tab" id="tab-continue">Continue</div>
    <div class="tab" id="tab-readlater">Read Later</div>
    <div class="tab" id="tab-favorites">Favorites</div>
  </div>
  <button id="themeToggle" class="small-btn" aria-label="Toggle Dark Mode" style="display:none">üåô</button>
</div>

<!-- Bottom Nav (Mobile) -->
<nav class="bottom-nav">
  <div class="nav-item active" id="nav-home">
    <span class="nav-item-icon">üè†</span>
    <span>Home</span>
  </div>
  <div class="nav-item" id="nav-continue">
    <span class="nav-item-icon">‚è±Ô∏è</span>
    <span>Continue</span>
  </div>
  <div class="nav-item" id="nav-readlater">
    <span class="nav-item-icon">üìå</span>
    <span>Saved</span>
  </div>
  <div class="nav-item" id="nav-favorites">
    <span class="nav-item-icon">‚ù§Ô∏è</span>
    <span>Favs</span>
  </div>
</nav>

<!-- search/filters -->
<div class="search-row">
  <input id="searchInput" placeholder="Search by title, author, or subject..." />
  <select id="genreFilter"><option value="">All Genres</option></select>
</div>

<!-- main content -->
<div class="layout" id="layout">
  <div id="homeSection">
    <h2 class="section-title">Browse Collection</h2>
    <div class="stats" id="stats">Loading books...</div>
    <div id="loadingProgress" class="loading-progress" style="display: none;">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%"></div>
      </div>
      <div class="progress-text" id="progressText">Loading...</div>
    </div>
    <div id="homeContent"></div>
    <button id="loadMoreGenres" class="load-more-genres-btn" style="display:none">Load More Genres</button>
  </div>

  <div id="continueSection" style="display:none">
    <h2 class="section-title">Continue Reading</h2>
    <div id="continueList" class="continue-grid"></div>
    <div id="continueEmpty" class="empty-note" style="display:none">Nothing to continue ‚Äî open a book and it will appear here.</div>
  </div>

  <div id="readLaterSection" style="display:none">
    <h2 class="section-title">Read Later</h2>
    <div id="readLaterList" class="readlater-grid"></div>
    <div id="readLaterEmpty" class="empty-note" style="display:none">No saved books ‚Äî add some using the "Read Later" button on a book card.</div>
  </div>

  <div id="favoritesSection" style="display:none">
    <h2 class="section-title">Favorites</h2>
    <div id="favoritesList" class="readlater-grid"></div>
    <div id="favoritesEmpty" class="empty-note" style="display:none">No favorites ‚Äî click the heart icon on a book to save it here.</div>
  </div>
</div>

<!-- Reader fullscreen -->
<div class="reader-fullscreen" id="reader">
  <div class="reader-header">
    <button id="readerBackBtn" class="reader-back-btn">‚óÄ Library</button>
    <div class="reader-title" id="readerTitle">Loading...</div>
    <button id="readerSettingsToggle" class="reader-settings-btn" aria-label="Reader Settings">‚öôÔ∏è</button>
  </div>

  <div id="readerSettingsPanel" class="settings-panel" style="display:none">
    <div class="settings-row">
      <span class="settings-label">Theme</span>
      <div class="settings-options">
        <button class="settings-btn" data-theme="light">Light</button>
        <button class="settings-btn" data-theme="sepia">Sepia</button>
        <button class="settings-btn" data-theme="dark">Dark</button>
      </div>
    </div>
    <div class="settings-row">
      <span class="settings-label">Font Family</span>
      <div class="settings-options">
        <button class="settings-btn" data-font="serif">Serif</button>
        <button class="settings-btn" data-font="sans">Sans</button>
        <button class="settings-btn" data-font="mono">Mono</button>
      </div>
    </div>
    <div class="settings-row">
      <span class="settings-label">Font Size</span>
      <div class="settings-options">
        <button class="settings-btn" id="fontDec">-</button>
        <button class="settings-btn" id="fontInc">+</button>
      </div>
    </div>
  </div>

  <div class="reader-body">
    <div class="page-container" id="pageContainer">
      <div class="page">
        <div class="page-content" id="pageContent">Loading...</div>
      </div>
    </div>

    <div class="nav-hit-left" id="navLeft">
      <div class="nav-arrow nav-arrow-left">‚óÄ</div>
    </div>
    <div class="nav-hit-right" id="navRight">
      <div class="nav-arrow nav-arrow-right">‚ñ∂</div>
    </div>

    <div class="reader-footer" id="readerFooter">
      <div class="reader-progress-bar">
        <div class="reader-progress-fill" id="readerProgressFill"></div>
      </div>
      <div class="page-indicator" id="pageIndicator">Page 1 / 1</div>
    </div>
  </div>
</div>

<script>
/* CONFIG - EASILY EDITABLE VALUES */
const PROXY_URL = "https://silent-brook-9ad3.dtech2j.workers.dev/"; // your Worker
const PROXY_KEY = "dtech_secret";
const WORDS_PER_PAGE_DEFAULT = 500;         // Change this value to adjust words per page
const MIN_BALANCE_RATIO = 0.40;             // minimum fraction for last page before rebalancing
const FONT_SIZE_DEFAULT = 9;                // Change this value to adjust font size
const BOOKS_PER_GENRE = 10;                 // Number of books to show per genre initially
const GENRES_PER_LOAD = 5;                  // Number of genres to show initially (reduced for faster loading)
const GENRES_PER_FILTER = 40;               // Number of genres to show in filter dropdown
const CHUNK_SIZE = 5000;                    // Size of data chunks to process at once

/* INDEXEDDB CONFIG */
const DB_NAME = 'GutenbergLibDB';
const DB_VERSION = 1;
const STORE_NAME = 'books';

/* STATE */
let books = [];
let pages = [];            // current pages (HTML strings)
let currentPage = 0;
let currentBook = null;    // {title, textUrl, cover, author}
let wordsPerPage = WORDS_PER_PAGE_DEFAULT;
let fontSize = FONT_SIZE_DEFAULT;
let readerTheme = 'sepia';
let readerFont = 'serif';
let pageIndicatorTimeout;
let genreDisplayCounts = {}; // Track how many books are shown per genre
let genresToShow = GENRES_PER_LOAD; // Track how many genres to display
let rawData = ""; // Store the raw data for lazy parsing
let processedData = ""; // Store already processed data
let searchIndex = {}; // Store search index for faster searching
let isProcessing = false; // Track if we're currently processing data

/* UI refs */
const booksGrid = document.getElementById('booksGrid');
const homeContent = document.getElementById('homeContent');
const statsEl = document.getElementById('stats');
const pageContent = document.getElementById('pageContent');
const pageIndicator = document.getElementById('pageIndicator');
const readerEl = document.getElementById('reader');
const readerTitle = document.getElementById('readerTitle');
const readerFooter = document.getElementById('readerFooter');
const loadMoreGenresBtn = document.getElementById('loadMoreGenres');
const loadingProgress = document.getElementById('loadingProgress');
const progressFill = document.getElementById('progressFill');
const progressText = document.getElementById('progressText');

/* Dark Mode */
const themeToggle = document.getElementById('themeToggle');
const savedTheme = localStorage.getItem('theme');

if (savedTheme === 'dark') {
  document.body.classList.add('dark-mode');
  themeToggle.textContent = '‚òÄÔ∏è';
}

themeToggle.addEventListener('click', () => {
  document.body.classList.toggle('dark-mode');
  const isDark = document.body.classList.contains('dark-mode');
  themeToggle.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
  localStorage.setItem('theme', isDark ? 'dark' : 'light');
});

/* Tabs & Mobile Nav */
const tabHome = document.getElementById('tab-home');
const tabContinue = document.getElementById('tab-continue');
const tabReadLater = document.getElementById('tab-readlater');
const tabFavorites = document.getElementById('tab-favorites');

const navHome = document.getElementById('nav-home');
const navContinue = document.getElementById('nav-continue');
const navReadLater = document.getElementById('nav-readlater');
const navFavorites = document.getElementById('nav-favorites');

const homeSection = document.getElementById('homeSection');
const continueSection = document.getElementById('continueSection');
const readLaterSection = document.getElementById('readLaterSection');
const favoritesSection = document.getElementById('favoritesSection');

// Desktop Tabs
tabHome.addEventListener('click', () => switchTab('home'));
tabContinue.addEventListener('click', () => switchTab('continue'));
tabReadLater.addEventListener('click', () => switchTab('readlater'));
tabFavorites.addEventListener('click', () => switchTab('favorites'));

// Mobile Nav
navHome.addEventListener('click', () => switchTab('home'));
navContinue.addEventListener('click', () => switchTab('continue'));
navReadLater.addEventListener('click', () => switchTab('readlater'));
navFavorites.addEventListener('click', () => switchTab('favorites'));

function switchTab(id){
  // Update desktop tabs
  tabHome.classList.remove('active');
  tabContinue.classList.remove('active');
  tabReadLater.classList.remove('active');
  tabFavorites.classList.remove('active');

  // Update mobile nav
  navHome.classList.remove('active');
  navContinue.classList.remove('active');
  navReadLater.classList.remove('active');
  navFavorites.classList.remove('active');

  // Hide all sections
  homeSection.style.display = 'none';
  continueSection.style.display = 'none';
  readLaterSection.style.display = 'none';
  favoritesSection.style.display = 'none';

  // Activate correct tab/nav and section
  if (id==='home'){
    tabHome.classList.add('active');
    navHome.classList.add('active');
    homeSection.style.display='block';
  }
  if (id==='continue'){
    tabContinue.classList.add('active');
    navContinue.classList.add('active');
    continueSection.style.display='block';
    renderContinueList();
  }
  if (id==='readlater'){
    tabReadLater.classList.add('active');
    navReadLater.classList.add('active');
    readLaterSection.style.display='block';
    renderReadLaterList();
  }
  if (id==='favorites'){
    tabFavorites.classList.add('active');
    navFavorites.classList.add('active');
    favoritesSection.style.display='block';
    renderFavoritesList();
  }
}

/* load data.txt and parse */
window.addEventListener('load', () => {
  loadBooks(false);
  loadReaderSettings();
});

/* INDEXEDDB FUNCTIONS */
function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = event => reject('IndexedDB error: ' + event.target.error);
    request.onsuccess = event => resolve(event.target.result);
    request.onupgradeneeded = event => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
      }
    };
  });
}

async function getAllBooksFromDB() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readonly');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.getAll();
    request.onsuccess = event => resolve(event.target.result);
    request.onerror = event => reject('Error getting books from DB: ' + event.target.error);
  });
}

async function addBooksToDB(booksToAdd) {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    // Clear existing to avoid duplicates if re-populating
    store.clear().onsuccess = () => {
      booksToAdd.forEach(book => store.add(book));
    };
    transaction.oncomplete = () => resolve();
    transaction.onerror = event => reject('Error adding books to DB: ' + event.target.error);
  });
}

async function clearBooksDB() {
  const db = await openDB();
  return new Promise((resolve, reject) => {
    const transaction = db.transaction([STORE_NAME], 'readwrite');
    const store = transaction.objectStore(STORE_NAME);
    const request = store.clear();
    request.onsuccess = () => resolve();
    request.onerror = event => reject('Error clearing DB: ' + event.target.error);
  });
}

async function loadBooks(forceRefresh = false){
  try {
    loadingProgress.style.display = 'flex';

    // 1. Try loading from IndexedDB first (unless forced refresh)
    if (!forceRefresh) {
      progressText.textContent = 'Checking local cache...';
      try {
        const cachedBooks = await getAllBooksFromDB();
        if (cachedBooks && cachedBooks.length > 0) {
          books = cachedBooks;
          loadingProgress.style.display = 'none';
          statsEl.innerHTML = `üìö ${books.length} books loaded from cache <button onclick="loadBooks(true)" class="small-btn" style="margin-left:10px">Refresh Data</button>`;
          renderHomePage();
          populateGenreFilter();

          // Show/hide load more genres button logic
          const genres = new Set(books.map(b => b.genre));
          if (genres.size > genresToShow) {
            loadMoreGenresBtn.style.display = 'block';
          } else {
            loadMoreGenresBtn.style.display = 'none';
          }
          return;
        }
      } catch (e) {
        console.warn('IndexedDB failed, falling back to network', e);
      }
    }

    // 2. Fetch data.txt
    progressText.textContent = 'Loading data file...';
    
    const r = await fetch('data.txt', {cache:'no-store'});
    if(!r.ok) throw new Error('Failed to fetch data.txt');
    
    const reader = r.body.getReader();
    const decoder = new TextDecoder();
    let receivedLength = 0;
    let chunks = [];
    
    while(true) {
      const {done, value} = await reader.read();
      if (done) break;
      
      chunks.push(value);
      receivedLength += value.length;
      
      // Update progress
      const progressPercent = Math.min(50, (receivedLength / (2 * 1024 * 1024)) * 50); // Assume 2MB file
      progressFill.style.width = `${progressPercent}%`;
      progressText.textContent = `Loading data... ${Math.round(progressPercent)}%`;
    }
    
    // Correctly join chunks
    let combined = new Uint8Array(receivedLength);
    let position = 0;
    for(let chunk of chunks) {
      combined.set(chunk, position);
      position += chunk.length;
    }
    rawData = decoder.decode(combined);

    progressFill.style.width = '50%';
    progressText.textContent = 'Processing data...';
    
    // Start processing data in chunks
    // Clear books array before processing if it was a refresh
    if (forceRefresh) books = [];
    processDataChunk(true); // pass true to indicate we should save to DB at end
  } catch(err){
    console.error('loadBooks', err);
    homeContent.innerHTML = '<div class="empty-note">Error loading data.txt ‚Äî open console.</div>';
    statsEl.textContent = 'üìö 0 books loaded';
    loadingProgress.style.display = 'none';
  }
}

/* Process data in chunks to avoid freezing */
function processDataChunk(saveToDB = false) {
  if (isProcessing) return;
  isProcessing = true;
  
  // If we have no processed data yet, start from the beginning
  if (processedData === "") {
    processedData = rawData;
  }
  
  // Process a chunk of data, careful not to split lines
  let chunkEnd = Math.min(CHUNK_SIZE, processedData.length);
  if (chunkEnd < processedData.length) {
    const lastNewline = processedData.lastIndexOf('\n', chunkEnd);
    if (lastNewline > 0) {
      chunkEnd = lastNewline + 1;
    }
  }

  const chunkToProcess = processedData.substring(0, chunkEnd);
  const remainingData = processedData.substring(chunkEnd);
  
  // Parse the chunk, appending to existing books
  parseDataChunk(chunkToProcess, true);
  
  // Update progress
  const progressPercent = 50 + (50 * (rawData.length - remainingData.length) / rawData.length);
  progressFill.style.width = `${progressPercent}%`;
  progressText.textContent = `Processing data... ${Math.round(progressPercent)}%`;
  
  // If there's more data to process, schedule next chunk
  if (remainingData.length > 0) {
    processedData = remainingData;
    setTimeout(() => {
      isProcessing = false;
      processDataChunk(saveToDB);
    }, 10); // Small delay to allow UI updates
  } else {
    // Finished processing
    loadingProgress.style.display = 'none';
    isProcessing = false;
    statsEl.innerHTML = `üìö ${books.length} books loaded ‚Ä¢ Use search/genre <button onclick="loadBooks(true)" class="small-btn" style="margin-left:10px">Refresh Data</button>`;

    if (saveToDB) {
      addBooksToDB(books).then(() => console.log('Books saved to DB')).catch(e => console.error(e));
    }
    
    // Show/hide load more genres button
    const totalGenres = countGenresInData(rawData);
    if (totalGenres > genresToShow) {
      loadMoreGenresBtn.style.display = 'block';
    } else {
      loadMoreGenresBtn.style.display = 'none';
    }
  }
}

/* Parse a chunk of data.txt */
function parseDataChunk(chunk, append = false) {
  const lines = chunk.split(/\r?\n/);
  let currentGenre = '';
  let currentBook = null;
  const parsed = [];
  let bookCount = 0;
  let genreCount = 0;

  for (let raw of lines){
    const line = raw.trim();
    if (!line) continue;
    if (line.includes('üéØ GENRE:')) {
      const m = line.match(/üéØ\s*GENRE:\s*([^\(]+)/i);
      currentGenre = m ? m[1].trim() : currentGenre;
      genreCount++;
      
      // If we've reached our genre limit, stop parsing
      if (genreCount > genresToShow) {
        break;
      }
      continue;
    }
    const bs = line.match(/^üìñ\s*BOOK\s*\d+\s*:\s*(.+)$/i);
    if (bs){
      if (currentBook) {
        parsed.push(currentBook);
        bookCount++;
        
        // If we've reached our book limit, stop parsing
        if (bookCount >= BOOKS_PER_GENRE * genresToShow) {
          break;
        }
      }
      currentBook = { genre: currentGenre, title: bs[1].trim() };
      continue;
    }
    if (!currentBook) continue;
    if (line.includes('üë§ Author:')) currentBook.author = line.split('üë§ Author:')[1].trim();
    else if (line.includes('üìù Text URL:')) currentBook.textUrl = line.split('üìù Text URL:')[1].trim();
    else if (line.includes('üñºÔ∏è  Cover:') || line.includes('üñºÔ∏è Cover:')) {
      // Extract cover URL correctly
      const coverMatch = line.match(/üñºÔ∏è\s*Cover:\s*(.+)/i);
      if (coverMatch) currentBook.cover = coverMatch[1].trim();
    }
    else if (/^-{6,}/.test(line)){ 
      parsed.push(currentBook); 
      bookCount++;
      currentBook = null; 
      
      // If we've reached our book limit, stop parsing
      if (bookCount >= BOOKS_PER_GENRE * genresToShow) {
        break;
      }
    }
  }
  if (currentBook) parsed.push(currentBook);

  // If we're appending to existing books
  if (append) {
    books = books.concat(parsed);
  } else {
    books = parsed;
  }

  renderHomePage();
  populateGenreFilter();
  renderContinueList();
}

/* Count total genres in the data file */
function countGenresInData(text) {
  const lines = text.split(/\r?\n/);
  let genreCount = 0;
  
  for (let raw of lines){
    const line = raw.trim();
    if (line.includes('üéØ GENRE:')) {
      genreCount++;
    }
  }
  
  return genreCount;
}

/* Load more genres */
loadMoreGenresBtn.addEventListener('click', () => {
  genresToShow += GENRES_PER_LOAD;
  processedData = rawData; // Reset to process from beginning with new limit
  books = []; // Clear books to rebuild with new limit
  processDataChunk(false);
});

/* Render home page with genre sections */
function renderHomePage(list=books){
  homeContent.innerHTML = '';
  if (!list.length) { 
    homeContent.innerHTML = '<div class="empty-note">No books found.</div>'; 
    return; 
  }
  
  // Group books by genre
  const booksByGenre = {};
  list.forEach(book => {
    if (!booksByGenre[book.genre]) {
      booksByGenre[book.genre] = [];
    }
    booksByGenre[book.genre].push(book);
  });
  
  // Initialize display counts if not set
  Object.keys(booksByGenre).forEach(genre => {
    if (!genreDisplayCounts[genre]) {
      genreDisplayCounts[genre] = BOOKS_PER_GENRE;
    }
  });
  
  // Sort genres by number of books (most to least)
  const sortedGenres = Object.keys(booksByGenre).sort((a, b) => {
    return booksByGenre[b].length - booksByGenre[a].length;
  });
  
  // Create sections for each genre
  sortedGenres.forEach(genre => {
    const genreBooks = booksByGenre[genre];
    const displayCount = genreDisplayCounts[genre];
    const booksToShow = genreBooks.slice(0, displayCount);
    
    const genreSection = document.createElement('div');
    genreSection.className = 'genre-section';
    
    const genreHeader = document.createElement('div');
    genreHeader.className = 'genre-header';
    
    const genreTitle = document.createElement('div');
    genreTitle.className = 'genre-title';
    genreTitle.innerHTML = `<span>${genre}</span>`;
    
    const genreCount = document.createElement('div');
    genreCount.className = 'genre-count';
    genreCount.textContent = `${booksToShow.length} of ${genreBooks.length} books`;
    
    genreHeader.appendChild(genreTitle);
    genreHeader.appendChild(genreCount);
    genreSection.appendChild(genreHeader);
    
    const booksGrid = document.createElement('div');
    booksGrid.className = 'books-grid';
    
    booksToShow.forEach(book => {
      const card = createBookCard(book);
      booksGrid.appendChild(card);
    });
    
    genreSection.appendChild(booksGrid);
    
    // Add "Load More" button if there are more books to show
    if (displayCount < genreBooks.length) {
      const loadMoreBtn = document.createElement('button');
      loadMoreBtn.className = 'load-more-btn';
      loadMoreBtn.textContent = `Load More (${genreBooks.length - displayCount} remaining)`;
      loadMoreBtn.addEventListener('click', () => {
        genreDisplayCounts[genre] += BOOKS_PER_GENRE;
        renderHomePage(list);
      });
      genreSection.appendChild(loadMoreBtn);
    }
    
    homeContent.appendChild(genreSection);
  });
}

/* Create book card for home page */
function createBookCard(book) {
  const card = document.createElement('div'); 
  card.className='book-card';
  
  const coverWrap = document.createElement('div'); 
  coverWrap.className='cover-wrap';
  
  if (book.cover){
    const img = document.createElement('img'); 
    img.src = book.cover;
    img.alt = book.title;
    img.onload = ()=>{/* ok */};
    img.onerror = ()=>{ coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(book.title)}</div>`; };
    coverWrap.appendChild(img);
  } else {
    coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(book.title)}</div>`;
  }

  const title = document.createElement('div'); 
  title.className='book-title'; 
  title.textContent = book.title;
  
  const author = document.createElement('div'); 
  author.className='book-author'; 
  author.textContent = book.author || '';
  
  const genre = document.createElement('div'); 
  genre.className='book-genre'; 
  genre.textContent = book.genre || '';
  
  const row = document.createElement('div'); 
  row.className='card-row';

  const readBtn = document.createElement('button'); 
  readBtn.className='btn'; 
  readBtn.innerHTML = 'üìñ Read';
  readBtn.addEventListener('click', (e)=>{ e.stopPropagation(); openBook(book); });

  const rlBtn = document.createElement('button'); 
  rlBtn.className='small-btn'; 
  rlBtn.textContent = isInReadLater(book.textUrl) ? 'Remove' : 'Read Later';
  rlBtn.addEventListener('click', (e)=>{ e.stopPropagation(); toggleReadLater(book); rlBtn.textContent = isInReadLater(book.textUrl) ? 'Remove' : 'Read Later'; });

  const favBtn = document.createElement('button');
  favBtn.className='small-btn';
  favBtn.innerHTML = isInFavorites(book.textUrl) ? '‚ù§Ô∏è' : 'ü§ç';
  favBtn.title = 'Toggle Favorite';
  favBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    toggleFavorite(book);
    favBtn.innerHTML = isInFavorites(book.textUrl) ? '‚ù§Ô∏è' : 'ü§ç';
  });

  row.appendChild(readBtn); 
  row.appendChild(rlBtn);
  row.appendChild(favBtn);
  card.appendChild(coverWrap); 
  card.appendChild(title); 
  card.appendChild(author); 
  card.appendChild(genre); 
  card.appendChild(row);
  
  // Clicking card reads
  card.addEventListener('click', ()=> openBook(book));
  
  return card;
}

/* helper short title */
function shortTitle(t){
  if (!t) return 'No title';
  return t.split(' ').slice(0,3).join(' ');
}

/* Genre filter / search */
function populateGenreFilter(){
  const sel = document.getElementById('genreFilter'); 
  sel.innerHTML = '<option value="">All Genres</option>';
  
  // Count books per genre
  const genreCounts = {};
  books.forEach(book => {
    if (book.genre) {
      genreCounts[book.genre] = (genreCounts[book.genre] || 0) + 1;
    }
  });
  
  // Sort genres by count (most to least)
  const sortedGenres = Object.keys(genreCounts).sort((a, b) => {
    return genreCounts[b] - genreCounts[a];
  });
  
  // Limit to top GENRES_PER_FILTER genres
  const topGenres = sortedGenres.slice(0, GENRES_PER_FILTER);
  
  // Add options with counts
  topGenres.forEach(g => { 
    const o = document.createElement('option'); 
    o.value = g; 
    o.textContent = `${g} (${genreCounts[g]})`; 
    sel.appendChild(o); 
  });
}

// Debounced search function
let searchTimeout;
document.getElementById('searchInput').addEventListener('input', (e)=>{
  clearTimeout(searchTimeout);
  searchTimeout = setTimeout(() => {
    const q = e.target.value.trim().toLowerCase();
    const genre = document.getElementById('genreFilter').value;
    
    if (q.length < 2 && !genre) {
      renderHomePage();
      return;
    }
    
    // Show loading indicator for search
    loadingProgress.style.display = 'flex';
    progressFill.style.width = '0%';
    progressText.textContent = 'Searching...';
    
    // Process search in chunks to avoid freezing
    processSearch(q, genre);
  }, 300);
});

function processSearch(query, genreFilter) {
  const filtered = [];
  let processed = 0;
  const totalBooks = books.length;
  const chunkSize = 100; // Process 100 books at a time
  
  function processChunk() {
    const chunkEnd = Math.min(processed + chunkSize, totalBooks);
    
    for (let i = processed; i < chunkEnd; i++) {
      const book = books[i];
      const searchText = (book.title + ' ' + (book.author||'') + ' ' + (book.genre||'')).toLowerCase();
      
      if ((!query || searchText.includes(query)) && (!genreFilter || book.genre === genreFilter)) {
        filtered.push(book);
      }
    }
    
    processed = chunkEnd;
    
    // Update progress
    const progressPercent = (processed / totalBooks) * 100;
    progressFill.style.width = `${progressPercent}%`;
    progressText.textContent = `Searching... ${Math.round(progressPercent)}%`;
    
    if (processed < totalBooks) {
      // Process next chunk on next frame
      setTimeout(processChunk, 0);
    } else {
      // Search complete
      loadingProgress.style.display = 'none';
      renderHomePage(filtered);
      statsEl.textContent = `üìö Found ${filtered.length} books matching your search`;
    }
  }
  
  processChunk();
}

document.getElementById('genreFilter').addEventListener('change', ()=> document.getElementById('searchInput').dispatchEvent(new Event('input')));

/* READ LATER (localStorage) */
function getReadLater(){ 
  try{ 
    return JSON.parse(localStorage.getItem('gutenberg:readlater')||'[]') 
  }catch(e){ 
    return [] 
  } 
}

function saveReadLater(list){ 
  localStorage.setItem('gutenberg:readlater', JSON.stringify(list)); 
}

function isInReadLater(url){ 
  if(!url) return false; 
  return getReadLater().some(i=>i.textUrl===url); 
}

function toggleReadLater(book){
  const list = getReadLater();
  const idx = list.findIndex(b=>b.textUrl===book.textUrl);
  if (idx === -1) { 
    list.unshift({
      title:book.title, 
      author:book.author, 
      textUrl:book.textUrl, 
      cover:book.cover,
      addedDate: new Date().toISOString()
    }); 
    saveReadLater(list); 
    showToast('Added to Read Later'); 
  }
  else { 
    list.splice(idx,1); 
    saveReadLater(list); 
    showToast('Removed from Read Later'); 
  }
  renderReadLaterList();
}

/* FAVORITES (localStorage) */
function getFavorites(){
  try{
    return JSON.parse(localStorage.getItem('gutenberg:favorites')||'[]')
  }catch(e){
    return []
  }
}

function saveFavorites(list){
  localStorage.setItem('gutenberg:favorites', JSON.stringify(list));
}

function isInFavorites(url){
  if(!url) return false;
  return getFavorites().some(i=>i.textUrl===url);
}

function toggleFavorite(book){
  const list = getFavorites();
  const idx = list.findIndex(b=>b.textUrl===book.textUrl);
  if (idx === -1) {
    list.unshift({
      title:book.title,
      author:book.author,
      textUrl:book.textUrl,
      cover:book.cover,
      addedDate: new Date().toISOString()
    });
    saveFavorites(list);
    showToast('Added to Favorites');
  }
  else {
    list.splice(idx,1);
    saveFavorites(list);
    showToast('Removed from Favorites');
  }
  if (document.getElementById('tab-favorites').classList.contains('active')) renderFavoritesList();
}

function renderFavoritesList(){
  const wrap = document.getElementById('favoritesList');
  const empty = document.getElementById('favoritesEmpty');
  const list = getFavorites();
  wrap.innerHTML='';
  empty.style.display='none';

  if (!list.length){
    empty.style.display='block';
    return;
  }

  list.forEach(b=>{
    const card = document.createElement('div');
    card.className = 'readlater-card'; // reuse style

    const coverWrap = document.createElement('div');
    coverWrap.className = 'readlater-cover';

    if (b.cover){
      const img = document.createElement('img');
      img.src = b.cover;
      img.onerror = () => {
        coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
      };
      coverWrap.appendChild(img);
    } else {
      coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    }

    const info = document.createElement('div');
    info.className = 'readlater-info';

    const title = document.createElement('div');
    title.className = 'readlater-title';
    title.textContent = b.title;

    const author = document.createElement('div');
    author.className = 'readlater-author';
    author.textContent = b.author || '';

    const date = document.createElement('div');
    date.className = 'readlater-date';
    date.textContent = `Added: ${formatDate(b.addedDate)}`;

    info.appendChild(title);
    info.appendChild(author);
    info.appendChild(date);

    const actions = document.createElement('div');
    actions.className = 'readlater-actions';

    const openBtn = document.createElement('button');
    openBtn.className = 'readlater-open';
    openBtn.textContent = 'Open';
    openBtn.addEventListener('click', () => openBook(b));

    const removeBtn = document.createElement('button');
    removeBtn.className = 'readlater-remove';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => {
      toggleFavorite(b);
    });

    actions.appendChild(openBtn);
    actions.appendChild(removeBtn);

    card.appendChild(coverWrap);
    card.appendChild(info);
    card.appendChild(actions);

    wrap.appendChild(card);
  });
}

/* render Read Later list */
function renderReadLaterList(){
  const wrap = document.getElementById('readLaterList');
  const empty = document.getElementById('readLaterEmpty');
  const list = getReadLater();
  wrap.innerHTML=''; 
  empty.style.display='none';
  
  if (!list.length){ 
    empty.style.display='block'; 
    return; 
  }
  
  list.forEach(b=>{
    const card = document.createElement('div');
    card.className = 'readlater-card';
    
    const coverWrap = document.createElement('div');
    coverWrap.className = 'readlater-cover';
    
    if (b.cover){ 
      const img = document.createElement('img'); 
      img.src = b.cover; 
      img.onerror = () => {
        coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
      }; 
      coverWrap.appendChild(img); 
    } else {
      coverWrap.innerHTML = `<div class="cover-placeholder">${shortTitle(b.title)}</div>`;
    }
    
    const info = document.createElement('div');
    info.className = 'readlater-info';
    
    const title = document.createElement('div');
    title.className = 'readlater-title';
    title.textContent = b.title;
    
    const author = document.createElement('div');
    author.className = 'readlater-author';
    author.textContent = b.author || '';
    
    const date = document.createElement('div');
    date.className = 'readlater-date';
    date.textContent = `Added: ${formatDate(b.addedDate)}`;
    
    info.appendChild(title);
    info.appendChild(author);
    info.appendChild(date);
    
    const actions = document.createElement('div');
    actions.className = 'readlater-actions';
    
    const openBtn = document.createElement('button');
    openBtn.className = 'readlater-open';
    openBtn.textContent = 'Open';
    openBtn.addEventListener('click', () => openBook(b));
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'readlater-remove';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => { 
      toggleReadLater(b); 
      renderReadLaterList(); 
    });
    
    actions.appendChild(openBtn);
    actions.appendChild(removeBtn);
    
    card.appendChild(coverWrap);
    card.appendChild(info);
    card.appendChild(actions);
    
    wrap.appendChild(card);
  });
}

/* CONTINUE READING: scan localStorage keys for last page markers */
function getContinueList(){
  const list=[];
  for (let i=0;i<localStorage.length;i++){
    const key = localStorage.key(i);
    if (!key) continue;
    if (key.startsWith('gutenberg:lastpage:')) {
      const url = key.replace('gutenberg:lastpage:','');
      const idx = parseInt(localStorage.getItem(key),10) || 0;
      const lastRead = localStorage.getItem('gutenberg:lastread:' + url) || '';
      
      // find book meta from books[] or readLater
      let meta = books.find(b=>b.textUrl===url) || getReadLater().find(b=>b.textUrl===url) || null;
      if (meta) {
        list.push({
          title:meta.title, 
          author:meta.author, 
          textUrl:url, 
          lastPage:idx,
          lastRead: lastRead,
          totalPages: parseInt(localStorage.getItem('gutenberg:totalpages:' + url) || '1', 10)
        });
      } else {
        list.push({
          title:url.split('/').slice(-1)[0], 
          author:'', 
          textUrl:url, 
          lastPage:idx,
          lastRead: lastRead,
          totalPages: parseInt(localStorage.getItem('gutenberg:totalpages:' + url) || '1', 10)
        });
      }
    }
  }
  // sort by most recently read
  return list.sort((a, b) => new Date(b.lastRead) - new Date(a.lastRead));
}

function renderContinueList(){
  const wrap = document.getElementById('continueList');
  const empty = document.getElementById('continueEmpty');
  const list = getContinueList();
  wrap.innerHTML=''; 
  empty.style.display='none';
  
  if (!list.length){ 
    empty.style.display='block'; 
    return; 
  }
  
  list.forEach(item=>{
    const card = document.createElement('div');
    card.className = 'continue-card';
    
    const header = document.createElement('div');
    header.className = 'continue-header';
    
    const title = document.createElement('div');
    title.className = 'continue-title';
    title.textContent = item.title;
    
    const date = document.createElement('div');
    date.className = 'continue-date';
    date.textContent = item.lastRead ? formatDate(item.lastRead) : 'Unknown';
    
    header.appendChild(title);
    header.appendChild(date);
    
    const author = document.createElement('div');
    author.className = 'continue-author';
    author.textContent = item.author || '';
    
    const progressContainer = document.createElement('div');
    progressContainer.className = 'progress-container';
    
    const progressInfo = document.createElement('div');
    progressInfo.className = 'progress-info';
    progressInfo.innerHTML = `<span>Page ${item.lastPage + 1} of ${item.totalPages}</span><span>${Math.round((item.lastPage / item.totalPages) * 100)}%</span>`;
    
    const progressBar = document.createElement('div');
    progressBar.className = 'progress-bar';
    
    const progressFill = document.createElement('div');
    progressFill.className = 'progress-fill';
    progressFill.style.width = `${(item.lastPage / item.totalPages) * 100}%`;
    
    progressBar.appendChild(progressFill);
    progressContainer.appendChild(progressInfo);
    progressContainer.appendChild(progressBar);
    
    const actions = document.createElement('div');
    actions.className = 'continue-actions';
    
    const continueBtn = document.createElement('button');
    continueBtn.className = 'continue-btn';
    continueBtn.textContent = 'Continue';
    continueBtn.addEventListener('click', () => openBook({title:item.title, textUrl:item.textUrl}));
    
    const removeBtn = document.createElement('button');
    removeBtn.className = 'remove-btn';
    removeBtn.textContent = 'Remove';
    removeBtn.addEventListener('click', () => { 
      localStorage.removeItem('gutenberg:lastpage:' + item.textUrl);
      localStorage.removeItem('gutenberg:lastread:' + item.textUrl);
      localStorage.removeItem('gutenberg:totalpages:' + item.textUrl);
      renderContinueList(); 
    });
    
    actions.appendChild(continueBtn);
    actions.appendChild(removeBtn);
    
    card.appendChild(header);
    card.appendChild(author);
    card.appendChild(progressContainer);
    card.appendChild(actions);
    
    wrap.appendChild(card);
  });
}

/* Format date for display */
function formatDate(dateString) {
  if (!dateString) return 'Unknown';
  
  const date = new Date(dateString);
  const now = new Date();
  const diffTime = Math.abs(now - date);
  const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
  
  if (diffDays === 0) {
    return 'Today';
  } else if (diffDays === 1) {
    return 'Yesterday';
  } else if (diffDays < 7) {
    return `${diffDays} days ago`;
  } else {
    return date.toLocaleDateString();
  }
}

/* Open book: fetch via worker, clean, paginate and render at saved page (if any) */
async function openBook(book){
  // book may be object or textUrl string
  const b = (typeof book === 'string') ? books.find(x=>x.textUrl===book) : book;
  if (!b || !b.textUrl) { alert('No text URL'); return; }
  currentBook = { title: b.title, textUrl: b.textUrl, author: b.author, cover: b.cover };

  readerTitle.textContent = currentBook.title || 'Untitled';
  showReader();

  try {
    const resp = await fetch(`${PROXY_URL}?url=${encodeURIComponent(currentBook.textUrl)}&key=${encodeURIComponent(PROXY_KEY)}`);
    if (!resp.ok) {
      const body = await resp.text().catch(()=>resp.statusText||'');
      throw new Error('Proxy fetch failed: ' + resp.status + ' ' + body);
    }
    const raw = await resp.text();
    const plain = extractPlainText(raw);
    paginateText(plain, wordsPerPage);
    // restore last page index
    const saved = parseInt(localStorage.getItem('gutenberg:lastpage:' + currentBook.textUrl) || '0', 10);
    currentPage = Math.max(0, Math.min(saved, pages.length - 1));
    renderPage(currentPage);
    // add to "continue" automatically (localStorage lastpage will be set by renderPage)
    renderContinueList();
  } catch (err) {
    console.error('openBook error', err);
    pageContent.innerHTML = `<div style="padding:18px;color:#c0392b">Failed to load book: ${escapeHtml(err.message || err)}</div>`;
  }
}

function showReader(){ 
  readerEl.style.display='block'; 
  document.body.style.overflow='hidden'; 
  // Reset page indicator visibility
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

function hideReader(){ 
  readerEl.style.display='none'; 
  document.body.style.overflow=''; 
  renderContinueList(); 
  renderReadLaterList(); 
  renderFavoritesList();
}

/* clean Gutenberg headers/footers and return plain text (paragraphs separated by double newline) */
function extractPlainText(raw){
  let s = (raw || '').replace(/\r\n/g, '\n');
  const U = s.toUpperCase();
  const startMarkers = ['*** START OF THE PROJECT GUTENBERG EBOOK','*** START OF THIS PROJECT GUTENBERG EBOOK','***START OF THE PROJECT GUTENBERG EBOOK','*** START'];
  let startIdx = -1;
  for (const m of startMarkers){ const i = U.indexOf(m); if (i !== -1){ startIdx = i; break; } }
  if (startIdx !== -1){
    // find next double newline after marker
    const after = s.indexOf('\n\n', startIdx);
    if (after !== -1) s = s.substring(after + 2);
    else s = s.substring(startIdx);
  } else {
    // remove typical metadata top blocks heuristically
    s = s.replace(/Title:.*\nAuthor:.*\nRelease date:.*\n/gi,'');
    s = s.replace(/The Project Gutenberg eBook of [\s\S]*?\n\n/gi, '');
  }

  // Remove footer/common license
  const footerMarkers = ['*** END OF THE PROJECT GUTENBERG EBOOK','*** END OF THIS PROJECT GUTENBERG EBOOK','END OF PROJECT GUTENBERG','END OF THE PROJECT GUTENBERG'];
  let endIdx = -1;
  const SU = s.toUpperCase();
  for (const fm of footerMarkers){ const i = SU.indexOf(fm); if (i !== -1){ endIdx = i; break; } }
  if (endIdx !== -1) s = s.substring(0, endIdx);

  // strip extra license paragraph remnants
  s = s.replace(/This ebook is for the use of anyone anywhere[\s\S]*?www\.gutenberg\.org\./gi, '');
  // normalize repeated blank lines
  s = s.replace(/\n{3,}/g, '\n\n').trim();

  return s;
}

/* PAGINATION: Improved algorithm to prevent cutting content */
function paginateText(plain, wordsPerPageLocal){
  const paragraphs = plain.split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);

  // Build pages by preserving paragraph boundaries
  const pagesArr = [];
  let currentPageText = '';
  let currentWordCount = 0;

  for (let para of paragraphs){
    const words = para.split(/\s+/).filter(Boolean);
    const paraWordCount = words.length;
    
    // If adding this paragraph would exceed the limit
    if (currentWordCount + paraWordCount > wordsPerPageLocal) {
      // If current page has content, push it
      if (currentPageText) {
        pagesArr.push(currentPageText);
        currentPageText = '';
        currentWordCount = 0;
      }
      
      // If paragraph is too long for a single page, split it
      if (paraWordCount > wordsPerPageLocal) {
        let remainingWords = paraWordCount;
        let startIdx = 0;
        
        while (remainingWords > 0) {
          const take = Math.min(remainingWords, wordsPerPageLocal);
          const chunk = words.slice(startIdx, startIdx + take).join(' ');
          pagesArr.push(chunk);
          startIdx += take;
          remainingWords -= take;
        }
      } else {
        // Paragraph fits in a new page
        currentPageText = para;
        currentWordCount = paraWordCount;
      }
    } else {
      // Add paragraph to current page
      if (currentPageText) {
        currentPageText += '\n\n' + para;
      } else {
        currentPageText = para;
      }
      currentWordCount += paraWordCount;
    }
  }
  
  // Don't forget the last page
  if (currentPageText) {
    pagesArr.push(currentPageText);
  }

  // Convert pages to HTML
  pages = pagesArr.map(pageText => {
    // Split by paragraphs and wrap each in <p> tags
    const pageParagraphs = pageText.split(/\n\s*\n/).filter(Boolean);
    return pageParagraphs.map(p => `<p>${escapeHtml(p)}</p>`).join('');
  });
  
  // Ensure non-empty
  if (!pages.length) pages = ['<p>No content extracted.</p>'];
  
  // Save total pages for progress tracking
  if (currentBook && currentBook.textUrl) {
    localStorage.setItem('gutenberg:totalpages:' + currentBook.textUrl, pages.length.toString());
  }
}

/* render a page (no horizontal scroll) */
function renderPage(idx){
  if (!pages || !pages.length) { pageContent.innerHTML = '<div class="empty-note">No pages</div>'; pageIndicator.textContent = 'Page 0 / 0'; return; }
  currentPage = Math.max(0, Math.min(idx, pages.length - 1));
  // set font size
  pageContent.style.fontSize = fontSize + 'px';
  pageContent.innerHTML = pages[currentPage];
  pageIndicator.textContent = `Page ${currentPage + 1} / ${pages.length}`;
  
  // Update Progress Bar
  const progressPercent = ((currentPage + 1) / pages.length) * 100;
  const fill = document.getElementById('readerProgressFill');
  if (fill) fill.style.width = `${progressPercent}%`;

  // Apply current reader font class to content
  pageContent.className = 'page-content'; // reset

  // save last page and last read timestamp
  try { 
    localStorage.setItem('gutenberg:lastpage:' + currentBook.textUrl, String(currentPage));
    localStorage.setItem('gutenberg:lastread:' + currentBook.textUrl, new Date().toISOString());
  } catch(e){}
  
  // ensure continue list refresh
  renderContinueList();
  
  // Show page indicator and set timeout to fade it
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

/* navigation handlers */
function navigatePage(direction) {
  if (direction === 'next') {
    renderPage(currentPage + 1);
  } else if (direction === 'prev') {
    renderPage(currentPage - 1);
  }
}

/* keyboard navigation */
window.addEventListener('keydown', (e)=>{
  if (readerEl.style.display === 'block'){
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { 
      navigatePage('next'); 
      e.preventDefault(); 
    }
    if (e.key === 'ArrowLeft' || e.key === 'PageUp') { 
      navigatePage('prev'); 
      e.preventDefault(); 
    }
    if (e.key === 'Escape') hideReader();
  }
});

/* swipe/tap navigation areas */
let tx=0, ty=0;
function touchStart(e){ 
  const t = e.touches ? e.touches[0] : e; 
  tx = t.clientX; 
  ty = t.clientY; 
  
  // Show page indicator on touch
  clearTimeout(pageIndicatorTimeout);
  readerFooter.classList.remove('hidden');
}
function touchEnd(e){ 
  const t = e.changedTouches ? e.changedTouches[0] : e; 
  const dx = t.clientX - tx; 
  const dy = t.clientY - ty; 
  if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 30){ 
    if (dx < 0) navigatePage('next'); 
    else navigatePage('prev'); 
  }
  
  // Set timeout to hide page indicator after touch
  pageIndicatorTimeout = setTimeout(() => {
    readerFooter.classList.add('hidden');
  }, 3000);
}

document.getElementById('navLeft').addEventListener('touchstart', touchStart); 
document.getElementById('navRight').addEventListener('touchstart', touchStart);
document.getElementById('navLeft').addEventListener('touchend', touchEnd); 
document.getElementById('navRight').addEventListener('touchend', touchEnd);
document.getElementById('navLeft').addEventListener('click', ()=> navigatePage('prev')); 
document.getElementById('navRight').addEventListener('click', ()=> navigatePage('next'));

// Click anywhere on reader to show page indicator temporarily
readerEl.addEventListener('click', (e) => {
  // Don't trigger if clicking on navigation areas
  if (e.target.id !== 'navLeft' && e.target.id !== 'navRight' && 
      !e.target.closest('#navLeft') && !e.target.closest('#navRight')) {
    clearTimeout(pageIndicatorTimeout);
    readerFooter.classList.remove('hidden');
    pageIndicatorTimeout = setTimeout(() => {
      readerFooter.classList.add('hidden');
    }, 3000);
  }
});

/* Reader Settings Logic */
const readerSettingsToggle = document.getElementById('readerSettingsToggle');
const readerSettingsPanel = document.getElementById('readerSettingsPanel');
const readerBackBtn = document.getElementById('readerBackBtn');

readerBackBtn.addEventListener('click', (e) => {
  e.stopPropagation();
  hideReader();
});

readerSettingsToggle.addEventListener('click', (e) => {
  e.stopPropagation();
  readerSettingsPanel.style.display = readerSettingsPanel.style.display === 'none' ? 'block' : 'none';
});

// Close panel when clicking outside
document.addEventListener('click', (e) => {
  if (readerSettingsPanel.style.display === 'block' &&
      !readerSettingsPanel.contains(e.target) &&
      e.target !== readerSettingsToggle) {
    readerSettingsPanel.style.display = 'none';
  }
});

// Font Size
document.getElementById('fontInc').addEventListener('click', (e) => { e.stopPropagation(); fontSize = Math.min(24, fontSize + 1); applyReaderSettings(); renderPage(currentPage); });
document.getElementById('fontDec').addEventListener('click', (e) => { e.stopPropagation(); fontSize = Math.max(8, fontSize - 1); applyReaderSettings(); renderPage(currentPage); });

// Theme & Font
document.querySelectorAll('.settings-btn[data-theme]').forEach(btn => {
  btn.addEventListener('click', (e) => { e.stopPropagation(); readerTheme = btn.dataset.theme; applyReaderSettings(); });
});
document.querySelectorAll('.settings-btn[data-font]').forEach(btn => {
  btn.addEventListener('click', (e) => { e.stopPropagation(); readerFont = btn.dataset.font; applyReaderSettings(); });
});

function loadReaderSettings() {
  try {
    const s = JSON.parse(localStorage.getItem('gutenberg:readerSettings'));
    if (s) {
      if (s.fontSize) fontSize = s.fontSize;
      if (s.theme) readerTheme = s.theme;
      if (s.font) readerFont = s.font;
    }
  } catch(e) {}
  applyReaderSettings();
}

function applyReaderSettings() {
  // Save
  localStorage.setItem('gutenberg:readerSettings', JSON.stringify({ fontSize, theme: readerTheme, font: readerFont }));

  // Apply Theme & Font
  readerEl.className = `reader-fullscreen theme-${readerTheme} font-${readerFont}`;

  // Update Buttons active state
  document.querySelectorAll('.settings-btn[data-theme]').forEach(b => b.classList.toggle('active', b.dataset.theme === readerTheme));
  document.querySelectorAll('.settings-btn[data-font]').forEach(b => b.classList.toggle('active', b.dataset.font === readerFont));

  // Font Size update live
  if (pageContent) pageContent.style.fontSize = fontSize + 'px';
}

/* CONTINUE & READ LATER helpers - after page change, these lists update */
function escapeHtml(s){ return (s||'').toString().replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* small toast */
function showToast(text){
  const t = document.createElement('div'); t.textContent = text; t.className = 'toast';
  document.body.appendChild(t); setTimeout(()=>t.remove(), 2000);
}

/* render both lists initially */
renderContinueList();
renderReadLaterList();

</script>
</body>
</html>
